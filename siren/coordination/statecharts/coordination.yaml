# Underlying assumptions:
# - Reliable (integrity and liveness) communication channels
# - Authenticated and signed communication
# - All messages/events are sent using reliable multicast - a controller sends its value to every member of the group reliably (integrity, validity, and agreement)
# - An upper bound, D, on propagation delay

statechart:
  name: Coordination
  # We assume:
  # - signal_id
  # - group_id
  # - ngi - number of groups in intersection
  # - schedule_decision - decision function for schedule sync
  # - Round
  # - Schedule
  # - T - transmission interval
  # - D - propagation delay
  # are defined appropriately in the interpreter context.
  # See https://sismic.readthedocs.io/en/latest/code.html#context-of-the-python-code-evaluator.
  preamble: |
    ag = set()  # active signal groups
    as = set()  # active signals
    r = {signal_id: Round(0, Schedule())}  # synchronization dict
    hb = {signal_id: 0}
    g = {signal_id: group_id}
    color = 'red'
    schedule = Schedule()
  root state:
    name: Node
    parallel states:
      - name: IntersectionHealth
        initial: StartIntersectionMonitoring
        states:
          - name: StartIntersectionMonitoring
            transitions:
              - target: DecideStart
                event: group_alive
                guard: event.group == group_id
                action: ag.add(group_id)
          - name: DecideStart
            transitions:
              - target: Running
                guard: len(ag) + 1 == ngi
              - target: Stopped
                guard: len(ag) + 1 < ngi
          - name: Stopped
            transitions:
              - target: Stopped
                event: dead_group
                action: ag.discard(event.group)
              - target: Running
                event: group_alive
                guard: len(ag) + 1 = ngi
                action: ag.add(event.group)
              - target: Stopped
                event: group_alive
                guard: len(ag) + 1 < ngi
                action: ag.add(event.group)
              - target: Running
                event: synchronized
                guard: len(ag) = ngi
            contract:
              - always: len(ag) < ngi
              - always: len(ag) >= 0
          - name: Running  # TODO: Update number of active signal groups and their ids (piggyback the heartbeat)
            transitions:
              - target: Stopped
                event: dead_group
                action: ag.discard(event.group)
            contract:
              - always: len(ag) == ngi
              - always: group_id in ag
      - name: SignalGroupHealth
        initial: StartGroupMonitoring
        states:
          - name: StartGroupMonitoring
            transitions:
              - target: HealthyGroup
                event: join_signal
                guard: event.signal == signal_id
                action: as.add(signal_id)
          - name: HealthyGroup
            on entry: send('group_alive', group=group_id)
            transitions:
              - target: HealthyGroup  # TODO: Update number of signals (piggyback the heartbeat)
                event: broken_signal
                guard: len(as) > 1
                action: as.discard(event.signal)
              - target: HealthyGroup
                event: join_signal
                action: |
                  as.add(event.signal)
                  g[event.signal] = event.group
              - target: DeadGroup
                event: broken_signal
                guard: len(as) == 1
            contract:
              - always: len(as) > 0
              - always: signal_id in as
          - name: DeadGroup
            on entry: send('dead_group', group=group_id)
            transitions:
              - target: HealthyGroup
                event: join_signal
                action: |
                  as.add(event.signal)
                  g[event.signal] = event.group
            contract:
              - always: len(as) == 0
      - name: SignalHealth
        initial: HealthyLights
        states:
          - name: HealthyLights
            on entry: send('join_signal', group=group_id, signal=signal_id)
            transitions:
              - target: BrokenLights
                event: dead_light
                guard: event.signal == signal_id
          - name: BrokenLights
            on entry: send('broken_signal', group=group_id, signal=signal_id)
      - name: LightControl
        # TODO: Implement conflict, green safety, yellow duration and starvation analysis - revert back to interval-based schedule if any violates the conditions. If that violates it too, shut off
        # TODO: Receive new schedule
        initial: Off
        states:
          - name: Off
            on entry: |
              send('light_off')
              color == 'red'
            transitions:
              - target: On
                guard: active('Running') and active('HealthyLights')
            contract:
              - after: color == 'red'
          - name: On
            on entry: send('light_on', signal=signal_id, color=color)
            transitions:
              - target: Off
                event: broken_signal
                guard: event.signal = signal_id
              - target: Off
                guard: active('Stopped') or schedule.empty(time)
              - target: On
                guard: not schedule.empty(time) and schedule[group_id, time] != color
                action: |
                  color = schedule[group_id, time]
                  send('light_on', signal=signal_id, color=color)
            contract:
              - before: not schedule.empty(time)
      - name: Synchronization
        # We want to synchronize the schedule amongst all the controllers.
        # Using reliable multicast, we can perform synchronization in rounds by everybody transmitting a tuple of (signal, round, schedule).
        # When every controller uses reliable multicast to transmit its values,
        # we know that every member of the group has received the values from everybody else.
        # The decision function for the schedules can be implemented as "select the latest schedule".
        # TODO: Implement synchronization
        intial: Send
        states:
          - name: Send
            on entry: send('sync_round', signal=signal_id, n=r[signal_id].n + 1, s=r[signal_id].s)
            on exit: r[signal_id].n += 1
          - name: Await
            transitions:
              - target: Decide
          - name: Decide
            on entry: schedule = schedule_decision(r, as)
            on exit: send('synchronized')
            transitions:
              - target: Send
      - name: Heartbeat
        # If we assume an interval, T, between heartbeats.
        # Then if the time between two heartbeats is more than T + 2 * D for any node, we can assume that this node is dead.
        transitions:
          - target: Heatbeat
            guard: time - hb[signal_id] > T
            action: send('heartbeat', signal=signal_id, group=group_id)
          - target: Heartbeat
            event: heartbeat
            action: |
              as.add(event.signal)
              ag.add(event.group)
              g[event.signal] = event.group
          - target: Heartbeat
            guard: |
              any(map(lambda b: time - b > T + 2 * D))
            action: |
              remove = list(map(lambda b: b[0], filter(lambda b: time - b[1] > T + 2 * D, hb.items())))
