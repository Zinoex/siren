# Underlying assumptions:
# - Reliable (integrity and liveness) communication channels
# - Authenticated and signed communication
# - All messages are sent using reliable multicast - a controller sends its value to everyone (in the group of signals)
# who each forward the same value to all the other lights (this implementation is reliable multicast over basic multicast).
# - An upper bound, D, on propagation delay

statechart:
  name: Coordination
  # In addition to the preamble, we assume signal_id and group_id is defined in the interpreter context.
  # See https://sismic.readthedocs.io/en/latest/code.html#context-of-the-python-code-evaluator.
  preamble: |
    ngi = 1  # number of signal groups at intersection
    ag = set()  # active signal groups
    as = set()  # active signals
    r = 0  # synchronization round
  root state:
    name: Node
    parallel states:
      - name: IntersectionHealth
        initial: StartIntersectionMonitoring
        states:
          - name: StartIntersectionMonitoring
            transitions:
              - target: Running
                event: group_alive
                guard: event.group == group_id
                action: ag.add(group_id)
          - name: Running  # TODO: Update number of active signal groups and their ids (piggyback the timesync)
            transitions:
              - target: Stopped
                event: dead_group
                action: ag.discard(event.group)
            contract:
              - always: len(ag) == ngi
          - name: Stopped
            transitions:
              - target: Stopped
                event: dead_group
                guard: len(ag) > 0
                action: ag.discard(event.group)
              - target: Running
                event: group_alive
                guard: len(ag) + 1 = ngi
                action: ag.add(event.group)
              - target: Stopped
                event: group_alive
                guard: len(ag) + 1 < ngi
                action: ag.add(event.group)
            contract:
              - always: len(ag) < ngi
              - always: len(ag) >= 0
      - name: SignalGroupHealth
        initial: StartGroupMonitoring
        states:
          - name: StartGroupMonitoring
            transitions:
              - target: HealthyGroup
                event: join_signal
                guard: event.signal == signal_id
                action: as.add(signal_id)
          - name: HealthyGroup
            on entry: send('group_alive', group=group_id)
            transitions:
              - target: HealthyGroup  # TODO: Update number of signals (piggyback the timesync)
                event: broken_signal
                guard: len(as) > 1
                action: as.discard(event.signal)
              - target: HealthyGroup
                event: join_signal
                action: as.add(event.signal)
              - target: DeadGroup
                event: broken_signal
                guard: len(as) == 1
            contract:
              - always: len(as) > 0
          - name: DeadGroup
            on entry: send('dead_group', group=group_id)
            transitions:
              - target: HealthyGroup
                event: join_signal
                action: as.add(event.signal)
            contract:
              - always: len(as) == 0
      - name: SignalHealth
        initial: HealthyLights
        states:
          - name: HealthyLights
            on entry: send('join_signal', group=group_id, signal=signal_id)
            transitions:
              - target: BrokenLights
                event: dead_light
                guard: event.signal == signal_id
          - name: BrokenLights
            on entry: send('broken_signal', group=group_id, signal=signal_id)
      - name: LightControl
      - name: TimeSync
        # When every controller uses reliable multicast to transmit its current timestamp,
        # we know that every member of the group has received the timestamp of everybody else.
        # A decision function (avg) is applied when all timestamps are received, and clocks are updated accordingly.
        #
        # If we assume an upper bound, T, on the interval between rounds of synchronization.
        # Then if the time between two rounds is more than T + D for any node, we can assume that this node is dead.